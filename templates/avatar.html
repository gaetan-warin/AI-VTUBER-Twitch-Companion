<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI CHAT BOT</title>
    <link rel="icon" href="static/favicon.ico" type="image/x-icon">

    <script src="static/live2dcubismcore.min.js"></script>
    <script src="static/live2d.min.js"></script>
    <script src="static/pixi.min.js"></script>
    <script src="static/browser.js"></script>

    <script src="static/gsap.min.js"></script>
    <script src="static/socket.io.min.js"></script>
    <link rel="stylesheet" href="static/style.css">
    <style>
        .speech-bubble {
            position: fixed;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 20px;
            padding: 15px 25px;
            max-width: 300px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1000;
            animation: fadeIn 0.3s ease-in;
            font-family: 'Arial', sans-serif;
            font-size: 14px;
            color: #333;
        }

        .speech-bubble:after {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 50%;
            border-width: 15px 15px 0;
            border-style: solid;
            border-color: #f5f7fa transparent;
            transform: translateX(-50%);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="speech-bubble" class="speech-bubble"></div>

    <div class="controls">
        <div class="input-group">
            <textarea id="makeItSpeak" placeholder="Enter text for the avatar to speak..."></textarea>
            <button id="speakBtn">Speak</button>
        </div>
    </div>

    <script>
        let modelPath = '';

        const synth = window.speechSynthesis;
        const mouthState = { value: 0 };
        let isSpeaking = false;
        let voicesReady = false;
        let currentModel = null;

        // WebSocket configuration
        const socket = io({
            transports: ['websocket'],
            reconnectionAttempts: 5,
            timeout: 3000
        });

        // Initialize application
        function main() {
            if (!modelPath) {
                console.error('Model path not set.');
                return;
            }

            const app = new PIXI.Application({
                view: document.getElementById('canvas'),
                autoStart: true,
                resizeTo: window,
                transparent: true, 
                antialias: true
            });

            app.ticker.add(() => {
                // mimic the interpolation value, 0-1
                if(isSpeaking)
                    mouthState.value = Math.sin(performance.now() / 200) / 2 + 0.5;
            });
        
            try {
                PIXI.live2d.Live2DModel.fromModelSettingsFile(modelPath).then(model => {
                    app.stage.addChild(model);
                    currentModel = model;
                    
                    model.anchor.set(0.5, 0.5);
                    model.position.set(innerWidth / 2, innerHeight / 2);
                    
                    const size = Math.min(innerWidth, innerHeight) * 0.8;
                    model.width = size;
                    model.height = size;
                    
                    const updateFn = model.internal.motionManager.update;
                    model.internal.motionManager.update = () => {
                        updateFn.call(model.internal.motionManager);
                        model.internal.coreModel.setParamFloat('PARAM_MOUTH_OPEN_Y', mouthState.value);
                    }
                });
            } catch (error) {
                console.error('Model loading error:', error);
            }
        }

        // Voice initialization
        synth.onvoiceschanged = () => {
            voicesReady = true;
            console.log('Voices loaded:', synth.getVoices());
        };

        function showSpeechBubble(text) {
            const bubble = document.getElementById('speech-bubble');
            bubble.textContent = text;
            bubble.style.display = 'block';

            if (currentModel) {
                const bounds = currentModel.getBounds();
                const x = window.innerWidth / 2;
                const y = (window.innerHeight / 2) - bounds.height / 2 - 50;
                
                bubble.style.left = `${x - bubble.offsetWidth / 2}px`;
                bubble.style.top = `${y}px`;
            }
        }

        function hideSpeechBubble() {
            const bubble = document.getElementById('speech-bubble');
            bubble.style.display = 'none';
        }

        // Speech functions
        function speak(text) {
            if (!text || !voicesReady) {
                console.log("Voices not loaded yet.");
                return;
            }

            if (isSpeaking) {
                synth.cancel();
                isSpeaking = false;
                gsap.killTweensOf(mouthState);
                hideSpeechBubble();
            }

            // Split text into sentences and wait times
            const parts = text.split(/(\{\*\d+\*\})|([.!?]\s+)/).filter(Boolean);

            let partIndex = 0;

            // Function to speak each part
            function speakNextPart() {
                if (partIndex < parts.length) {
                    let currentPart = parts[partIndex];
                    const waitMatch = currentPart.match(/\{\*(\d+)\*\}/);

                    if (waitMatch) {
                        const waitTime = parseInt(waitMatch[1], 10);
                        setTimeout(() => {
                            partIndex++;
                            speakNextPart();
                        }, waitTime);
                    } else {
                        // Extract punctuation from the part to be spoken
                        const punctuationMatch = currentPart.match(/[.!?]\s*$/);
                        const punctuation = punctuationMatch ? punctuationMatch[0] : '';
                        const textToSpeak = currentPart.replace(/[.!?]\s*$/, '').trim();
                        showSpeechBubble(textToSpeak + punctuation); // Show speech bubble with punctuation
                        
                        const utterance = new SpeechSynthesisUtterance(textToSpeak);
                        const voice = synth.getVoices().find(v => v.name.includes('Female')) || synth.getVoices()[0];

                        Object.assign(utterance, {
                            voice: voice,
                            pitch: 1.1,
                            rate: 0.95
                        });

                        utterance.onstart = () => {
                            isSpeaking = true;
                            // Animate mouth using GSAP with sine wave pattern
                            gsap.to(mouthState, {
                                duration: 0.2,
                                value: 1,
                                repeat: -1,
                                yoyo: true,
                                ease: "sine.inOut",
                                modifiers: {
                                    value: () => Math.abs(Math.sin(performance.now() / 200)) * 0.8
                                }
                            });
                        };

                        utterance.onend = () => {
                            isSpeaking = false;
                            gsap.killTweensOf(mouthState);
                            gsap.to(mouthState, {
                                duration: 0.3,
                                value: 0,
                                ease: "power2.out"
                            });
                            hideSpeechBubble(); // Hide speech bubble when speech ends
                            partIndex++;
                            // Add a short pause for punctuation
                            if (punctuation) {
                                setTimeout(speakNextPart, 500);
                            } else {
                                speakNextPart();
                            }
                        };

                        synth.speak(utterance);
                    }
                }
            }

            speakNextPart(); // Start speaking the first part
        }


        function setupEventListeners() {
            document.getElementById('speakBtn').addEventListener('click', () => {
                const inputField = document.getElementById('makeItSpeak');
                const text = inputField.value.trim();
                if (text) {
                    socket.emit('speak', { text });
                    inputField.value = ''; // Clear the input field
                }
            });

            document.getElementById('makeItSpeak').addEventListener('keydown', (event) => {
                if (event.ctrlKey && event.key === 'Enter') {
                    const inputField = event.target;
                    const text = inputField.value.trim();
                    if (text) {
                        socket.emit('speak', { text });
                        inputField.value = ''; // Clear the input field
                    }
                }
            });

            socket.on('speak_text', data => {
                console.log("Received text to speak:", data.text);
                speak(data.text);
            });

            socket.on('model_path', data => {
                modelPath = data.path;
                console.log("Received model path:", modelPath);
                main();
            });
            
            socket.on('connect', () => console.log('WebSocket connected:', socket.id));
            socket.on('disconnect', () => console.log('WebSocket disconnected'));
        }

        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            socket.connect();
            socket.emit('request_model_path');
        });
    </script>
</body>
</html>