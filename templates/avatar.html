<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI CHAT BOT</title>
    <link rel="icon" href="static/favicon.ico" type="image/x-icon">

    <script src="static/live2dcubismcore.min.js"></script>
    <script src="static/live2d.min.js"></script>
    <script src="static/pixi.min.js"></script>
    <script src="static/browser.js"></script>

    <script src="static/gsap.min.js"></script>
    <script src="static/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="speech-bubble" class="speech-bubble"></div>
    <div id="question-display" class="question-display" style="display: none;"></div>
    <div id="notification" class="notification"></div>

    <div class="controls">
        <div class="input-group">
            <textarea id="makeItSpeak" placeholder="Enter text for the avatar to speak or ask AI..."></textarea>
            <div class="button-group">
                <button id="speakBtn">Speak</button>
                <button id="askAIBtn">Ask AI</button>
            </div>
        </div>
    </div>

    <div id="sidebar" class="sidebar">
        <div class="sidebar-header">
            <h2>Configuration</h2>
            <button id="toggleSidebarBtn">Collapse</button>
        </div>
        <div class="sidebar-tabs">
            <button class="tab-button active" data-tab="general">General</button>
            <button class="tab-button" data-tab="technical">Technical</button>
        </div>
        <div class="sidebar-content">
            <div class="tab-content" id="general" style="display: block;">
                <div class="settings-container">
                    <label for="avatarModel">Avatar Model:</label>
                    <input type="text" id="avatarModel" value="shizuku">
                    <label for="personaName">Persona Name:</label>
                    <input type="text" id="personaName" value="Sarah">
                    <label for="personaRole">Persona Role:</label>
                    <textarea id="personaRole">Virtual assistant providing calm and engaging interactions.</textarea>
                    <label for="prePrompt">Pre Prompt:</label>
                    <textarea id="prePrompt">Please respond concisely and avoid monologues. Ensure your behavior strictly adheres to Twitch's Terms of Service, Community Guidelines, and Developer Agreement. Filter out prohibited content (hate speech, threats, etc.), promote respectful interactions, avoid illegal or harmful activities, prevent spam, respect user privacy, and always identify yourself as a bot. Follow channel-specific rules, provide neutral responses when unsure, and be updated regularly to comply with any changes in Twitch's policies.</textarea>
                </div>
            </div>
            <div class="tab-content" id="technical" style="display: none;">
                <div class="settings-container">
                    <div class="settings-section">
                        <h3>AI Settings</h3>
                        <label for="ollamaModel">Ollama Model:</label>
                        <select id="ollamaModel"></select>
                    </div>

                    <div class="settings-section">
                        <h3>Twitch Connection</h3>
                        <label for="channelName">Channel Name:</label>
                        <input type="text" id="channelName" value="ai_chat_bot">
                        <label for="token">Twitch Token:</label>
                        <input type="text" id="token" value="YOUR_TWITCH_TOKEN">
                        <label for="clientId">Twitch Client ID:</label>
                        <input type="text" id="clientId" value="YOUR_TWITCH_CLIENT_ID">
                    </div>

                    <div class="settings-section">
                        <h3>Bot Behavior</h3>
                        <label for="extraDelayListener">Extra Delay Listener:</label>
                        <input type="number" id="extraDelayListener" value="3" step="0.5">
                        <label for="nbSpamMessage">Spam Time Window:</label>
                        <input type="number" id="nbSpamMessage" value="3" step="0.5">
                    </div>

                    <div class="settings-section">
                        <h3>Follow/Sub Settings</h3>
                        <label for="botNameFollowSub">Follow/Sub Bot Name:</label>
                        <input type="text" id="botNameFollowSub" value="botwarga">
                        <label for="keyWordFollow">Follow Keyword:</label>
                        <input type="text" id="keyWordFollow" value="New FOLLOW(S)">
                        <label for="keyWordSub">Sub Keyword:</label>
                        <input type="text" id="keyWordSub" value="NEW SUB">
                        <label for="delimiterName">Name Delimiter Start:</label>
                        <input type="text" id="delimiterName" value="{">
                        <label for="delimiterNameEnd">Name Delimiter End:</label>
                        <input type="text" id="delimiterNameEnd" value="}">
                    </div>
                </div>
            </div>
            <div class="save-button-container">
                <button id="saveConfigBtn">Save Configuration</button>
            </div>
        </div>
    </div>

    <button id="toggleSidebarBtnCollapsed" class="toggle-sidebar-btn-collapsed">
        <img src="static/expand-icon.webp" alt="Expand">
    </button>

    <script>
        let modelPath = '';

        const synth = window.speechSynthesis;
        const mouthState = { value: 0 };
        let isSpeaking = false;
        let voicesReady = false;
        let currentModel = null;

        // WebSocket configuration
        const socket = io({
            transports: ['websocket'],
            reconnectionAttempts: 5,
            timeout: 3000
        });

        // Add this audio element to the body
        const celebrationAudio = new Audio('static/success.mp3');
        celebrationAudio.volume = 0.3; // Set volume to 30%
        celebrationAudio.preload = 'auto'; // Preload the audio

        // Initialize application
        function main() {
            if (!modelPath) {
                console.error('Model path not set.');
                return;
            }

            const app = new PIXI.Application({
                view: document.getElementById('canvas'),
                autoStart: true,
                resizeTo: window,
                transparent: true,
                antialias: true
            });

            app.ticker.add(() => {
                // mimic the interpolation value, 0-1
                if(isSpeaking)
                    mouthState.value = Math.sin(performance.now() / 200) / 2 + 0.5;
            });

            try {
                PIXI.live2d.Live2DModel.fromModelSettingsFile(modelPath).then(model => {
                    app.stage.addChild(model);
                    currentModel = model;

                    model.anchor.set(0.5, 0.5);
                    model.position.set(innerWidth / 2, innerHeight / 2);

                    const size = Math.min(innerWidth, innerHeight) * 0.8;
                    model.width = size;
                    model.height = size;

                    const updateFn = model.internal.motionManager.update;
                    model.internal.motionManager.update = () => {
                        updateFn.call(model.internal.motionManager);
                        model.internal.coreModel.setParamFloat('PARAM_MOUTH_OPEN_Y', mouthState.value);
                    }
                });
            } catch (error) {
                console.error('Model loading error:', error);
            }
        }

        // Voice initialization
        synth.onvoiceschanged = () => {
            voicesReady = true;
            console.log('Voices loaded:', synth.getVoices());
        };

        function showSpeechBubble(text) {
            const bubble = document.getElementById('speech-bubble');
            bubble.textContent = text;
            bubble.style.display = 'block';

            if (currentModel) {
                const bounds = currentModel.getBounds();
                const x = window.innerWidth / 2;
                const y = (window.innerHeight / 2) - bounds.height / 2 - 50;

                bubble.style.left = `${x - bubble.offsetWidth / 2}px`;
                bubble.style.top = `${y}px`;
            }
        }

        function hideSpeechBubble() {
            const bubble = document.getElementById('speech-bubble');
            bubble.style.display = 'none';
        }

        // Speech functions
        function speak(text) {
            if (!text || !voicesReady) {
                console.log("Voices not loaded yet.");
                return;
            }

            if (isSpeaking) {
                synth.cancel();
                isSpeaking = false;
                gsap.killTweensOf(mouthState);
                hideSpeechBubble();
            }

            // Split text into sentences and wait times
            const parts = text.split(/(\{\*\d+\*\})|([.!?]\s+)/).filter(Boolean);

            let partIndex = 0;

            // Function to speak each part
            function speakNextPart() {
                if (partIndex < parts.length) {
                    let currentPart = parts[partIndex];
                    const waitMatch = currentPart.match(/\{\*(\d+)\*\}/);

                    if (waitMatch) {
                        const waitTime = parseInt(waitMatch[1], 10);
                        setTimeout(() => {
                            partIndex++;
                            speakNextPart();
                        }, waitTime);
                    } else {
                        // Extract punctuation from the part to be spoken
                        const punctuationMatch = currentPart.match(/[.!?]\s*$/);
                        const punctuation = punctuationMatch ? punctuationMatch[0] : '';
                        const textToSpeak = currentPart.replace(/[.!?]\s*$/, '').trim();
                        showSpeechBubble(textToSpeak + punctuation); // Show speech bubble with punctuation

                        const utterance = new SpeechSynthesisUtterance(textToSpeak);
                        const voice = synth.getVoices().find(v => v.name.includes('Female')) || synth.getVoices()[0];

                        Object.assign(utterance, {
                            voice: voice,
                            pitch: 1.1,
                            rate: 0.95
                        });

                        utterance.onstart = () => {
                            isSpeaking = true;
                            // Animate mouth using GSAP with sine wave pattern
                            gsap.to(mouthState, {
                                duration: 0.2,
                                value: 1,
                                repeat: -1,
                                yoyo: true,
                                ease: "sine.inOut",
                                modifiers: {
                                    value: () => Math.abs(Math.sin(performance.now() / 200)) * 0.8
                                }
                            });
                        };

                        utterance.onend = () => {
                            isSpeaking = false;
                            gsap.killTweensOf(mouthState);
                            gsap.to(mouthState, {
                                duration: 0.3,
                                value: 0,
                                ease: "power2.out"
                            });
                            hideSpeechBubble(); // Hide speech bubble when speech ends
                            partIndex++;
                            // Add a short pause for punctuation
                            if (punctuation) {
                                setTimeout(speakNextPart, 500);
                            } else {
                                speakNextPart();
                            }
                        };

                        synth.speak(utterance);
                    }
                }
            }

            speakNextPart(); // Start speaking the first part
        }

        function askAI(text) {
            if (!text) {
                console.log("No text provided.");
                return;
            }

            socket.emit('ask_ai', { text });
        }

        function setupEventListeners() {
            document.getElementById('speakBtn').addEventListener('click', () => {
                const inputField = document.getElementById('makeItSpeak');
                const text = inputField.value.trim();
                if (text) {
                    socket.emit('speak', { text });
                    inputField.value = ''; // Clear the input field
                }
            });

            document.getElementById('askAIBtn').addEventListener('click', () => {
                const inputField = document.getElementById('makeItSpeak');
                const text = inputField.value.trim();
                if (text) {
                    askAI(text);
                    inputField.value = ''; // Clear the input field
                }
            });

            document.getElementById('makeItSpeak').addEventListener('keydown', (event) => {
                if (event.ctrlKey && event.key === 'Enter') {
                    const inputField = event.target;
                    const text = inputField.value.trim();
                    if (text) {
                        socket.emit('speak', { text });
                        inputField.value = ''; // Clear the input field
                    }
                }
            });

            document.getElementById('toggleSidebarBtn').addEventListener('click', () => {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.toggle('collapsed');
                document.getElementById('toggleSidebarBtn').textContent = sidebar.classList.contains('collapsed') ? 'Expand' : 'Collapse';
                document.getElementById('toggleSidebarBtnCollapsed').style.display = sidebar.classList.contains('collapsed') ? 'block' : 'none';
            });

            document.getElementById('toggleSidebarBtnCollapsed').addEventListener('click', () => {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.remove('collapsed');
                document.getElementById('toggleSidebarBtn').textContent = 'Collapse';
                document.getElementById('toggleSidebarBtnCollapsed').style.display = 'none';
            });

            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', () => {
                    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(content => content.style.display = 'none');
                    button.classList.add('active');
                    document.getElementById(button.dataset.tab).style.display = 'block';
                });
            });

            document.getElementById('saveConfigBtn').addEventListener('click', () => {
                const personaName = document.getElementById('personaName').value.trim();
                const personaRole = document.getElementById('personaRole').value.trim();
                const channelName = document.getElementById('channelName').value.trim();
                const token = document.getElementById('token').value.trim();
                const clientId = document.getElementById('clientId').value.trim();
                const extraDelayListener = document.getElementById('extraDelayListener').value.trim();
                const nbSpamMessage = document.getElementById('nbSpamMessage').value.trim();
                const prePrompt = document.getElementById('prePrompt').value.trim();
                const ollamaModel = document.getElementById('ollamaModel').value.trim();
                const avatarModel = document.getElementById('avatarModel').value.trim();
                const botNameFollowSub = document.getElementById('botNameFollowSub').value.trim();
                const keyWordFollow = document.getElementById('keyWordFollow').value.trim();
                const keyWordSub = document.getElementById('keyWordSub').value.trim();
                const delimiterName = document.getElementById('delimiterName').value.trim();
                const delimiterNameEnd = document.getElementById('delimiterNameEnd').value.trim();

                // Save configuration to .env file
                const config = {
                    PERSONA_NAME: personaName,
                    PERSONA_ROLE: personaRole,
                    PRE_PROMPT: prePrompt,
                    AVATAR_MODEL: avatarModel,
                    CHANNEL_NAME: channelName,
                    TOKEN: token,
                    CLIENT_ID: clientId,
                    EXTRA_DELAY_LISTENER: extraDelayListener,
                    NB_SPAM_MESSAGE: nbSpamMessage,
                    OLLAMA_MODEL: ollamaModel,
                    BOT_NAME_FOLLOW_SUB: botNameFollowSub,
                    KEY_WORD_FOLLOW: keyWordFollow,
                    KEY_WORD_SUB: keyWordSub,
                    DELIMITER_NAME: delimiterName,
                    DELIMITER_NAME_END: delimiterNameEnd
                };
                socket.emit('save_config', config);
            });

            socket.on('speak_text', data => {
                console.log("Received text to speak:", data.text);
                speak(data.text);
            });

            socket.on('model_path', data => {
                modelPath = data.path;
                console.log("Received model path:", modelPath);
                main();
            });

            socket.on('ai_response', data => {
                console.log("Received AI response:", data.text);
                speak(data.text);
            });

            socket.on('display_question', data => {
                showQuestionDisplay(`${data.username}: ${data.question}`);
            });

            socket.on('fireworks', data => {
                console.log(data.message);
                triggerFireworks();
            });

            socket.on('connect', () => console.log('WebSocket connected:', socket.id));
            socket.on('disconnect', () => console.log('WebSocket disconnected'));

            socket.on('load_config', data => {
                document.getElementById('personaName').value = data.PERSONA_NAME || '';
                document.getElementById('personaRole').value = data.PERSONA_ROLE || '';
                document.getElementById('prePrompt').value = data.PRE_PROMPT || '';
                document.getElementById('avatarModel').value = data.AVATAR_MODEL || '';
                document.getElementById('channelName').value = data.CHANNEL_NAME || '';
                document.getElementById('token').value = data.TOKEN || '';
                document.getElementById('clientId').value = data.CLIENT_ID || '';
                document.getElementById('extraDelayListener').value = data.EXTRA_DELAY_LISTENER || '';
                document.getElementById('nbSpamMessage').value = data.NB_SPAM_MESSAGE || '';
                document.getElementById('ollamaModel').value = data.OLLAMA_MODEL || '';
                document.getElementById('botNameFollowSub').value = data.BOT_NAME_FOLLOW_SUB || '';
                document.getElementById('keyWordFollow').value = data.KEY_WORD_FOLLOW || '';
                document.getElementById('keyWordSub').value = data.KEY_WORD_SUB || '';
                document.getElementById('delimiterName').value = data.DELIMITER_NAME || '';
                document.getElementById('delimiterNameEnd').value = data.DELIMITER_NAME_END || '';
            });

            socket.on('save_config_response', function(response) {
                if (response.status === 'success') {
                    showNotification('success', 'Configuration saved successfully');
                } else {
                    showNotification('error', response.message);
                }
            });
        }

        function showQuestionDisplay(text) {
            const questionDisplay = document.getElementById('question-display');
            questionDisplay.textContent = text;
            questionDisplay.style.display = 'block';
            clearTimeout(questionDisplay.hideTimeout);
            questionDisplay.hideTimeout = setTimeout(() => {
                questionDisplay.style.display = 'none';
            }, 10000);
        }

        function populateOllamaModels() {
            fetch('/get_ollama_models')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        const select = document.getElementById('ollamaModel');
                        data.models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model;
                            option.textContent = model;
                            select.appendChild(option);
                        });
                    } else {
                        console.error('Failed to load Ollama models:', data.message);
                    }
                })
                .catch(error => console.error('Error fetching Ollama models:', error));
        }

        function triggerFireworks() {
            // Play celebration sound
            celebrationAudio.currentTime = 0; // Reset audio to start
            const playPromise = celebrationAudio.play();

            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.log("Audio playback failed:", error);
                });
            }

            // Create multiple bursts of confetti
            const duration = 5 * 1000;
            const animationEnd = Date.now() + duration;
            const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 0 };

            function randomInRange(min, max) {
                return Math.random() * (max - min) + min;
            }

            const interval = setInterval(function() {
                const timeLeft = animationEnd - Date.now();

                if (timeLeft <= 0) {
                    return clearInterval(interval);
                }

                const particleCount = 50 * (timeLeft / duration);

                // Create confetti from random positions
                confetti({
                    ...defaults,
                    particleCount,
                    origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
                });
                confetti({
                    ...defaults,
                    particleCount,
                    origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
                });
            }, 250);

            // Add some special effects
            confetti({
                particleCount: 100,
                spread: 70,
                origin: { y: 0.6 },
                colors: ['#ff0000', '#00ff00', '#0000ff']
            });
        }

        function showNotification(type, message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;

            // Show notification
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);

            // Hide notification after 3 seconds
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            socket.connect();
            socket.emit('request_model_path');
            populateOllamaModels();
            socket.emit('load_config');
        });
    </script>

    <style>
        .fireworks-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }
    </style>
</body>
</html>